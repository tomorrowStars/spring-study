# 1，mysql的数据库默认自动提交

 查看是否自动提交命令（ON表示开启自动提交，值为1，OFF表示关闭自动提交，值为0）：

```
show variables like  'autocommit' ;
```

对于[mysql](http://lib.csdn.net/base/mysql)数据库，默认情况下，数据库处于自动提交模式。每一条语句处于一个单独的事务中，在这条语句执行完毕时，如果执行成功则隐式的提交事务，如果执行失败则隐式的回滚事务。对于正常的事务管理，是一组相关的操作处于一个事务之中，因此必须关闭数据库的自动提交模式，

关闭自动提交后，则用户将一直处于某个事务中，直到执行一条commit提交或rollback语句才会结束当前事务重新开始一个新的事务。





# 2，mybatis通过sqlSessionFactory来获取SQL session

- 非自动提交session

```
openSession();
```

- 自动提交session

```
openSession(boolean autoCommit);
```



# 3，[spring](http://lib.csdn.net/base/javaee)连接

## 二、[spring](http://lib.csdn.net/base/javaee)连接

 如果结合Spring来获取数据库连接，就不用担心，spring会将底层连接的自动提交特性设置为false，先看下Spring事务配置：

```xml
<!-- 配置事务 -->  
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">  
    <property name="dataSource" ref="dataSource" />  
</bean>  
<tx:annotation-driven transaction-manager="transactionManager"/>
```



上面配置中，重要的是类：org.springframework.jdbc.datasource.DataSourceTransactionManager，看其对自动提交的处理：

```java
    protected void doBegin(Object transaction, TransactionDefinition definition) {  
        //......  
        if(con.getAutoCommit()) {  
            txObject.setMustRestoreAutoCommit(true);  
            if(this.logger.isDebugEnabled()) {  
                this.logger.debug("Switching JDBC Connection [" + con + "] to manual commit");  
            }  
            con.setAutoCommit(false);  
        }  
        //......  
    }  
```



## 三、建议：当一个连接关闭时，如果有未提交的事务则回滚任何未提交的事务（C3P0默认的策略，C3P0的autoCommitOnClose属性默认是false）



# 二：Spring如何设置让事务自动提交和回滚？Spring两种事务管理方式的配置及使用

更多spring事务问题请访问链接：Spring事务回滚疑难详解
1，我们要明确，Spring如何设置让事务自动提交和回滚？
       ①如何自动提交？

          理论上，可以通过对DataSource如下设置，让事务自动提交

[html]  view plain  copy

<!-- 配置数据源 -->  
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">                
   <property name="defaultAutoCommit" value="true"></property>  
</bean>  
          实际上，这个设置对于大多数数据源是没有必要的，例如"org.apache.commons.dbcp.BasicDataSource"

        （我们可以通过反编译插件或者反编译工具浏览该jar包），我们发现

 



[java]  view plain  copy


 public BasicDataSource() {  
    this.defaultAutoCommit = true;  
    this.defaultReadOnly = null;  
/*此类通过无参的构造方法实例化：new BasicDataSource（）*/  
         上述表明：该数据源通过构造方法，初始化成员变量，defaultAutoCommit默认为true。

​        

     ②如何自动回滚？

 



         详情访问链接：Spring事务为什么没有回滚？Spring事务怎样才会回滚？事务回滚的条件

 



2，想要Spring对事务实现自动管理，首先我们要为数据源配置事务管理器

 

        SSH中配置如下：

 



[html]  view plain  copy


<!-- 配置数据源 -->  
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">   
    <property name="driverClassName" value="${jdbc_driverClassName}"></property>  
</bean>  
<!-- 配置SessionFactory -->  
<bean id="sessionFactory"    class="org.springframework.orm.hibernate4.LocalSessionFactoryBean">  
    <property name="dataSource" ref="dataSource" />     
</bean>  
<!-- 配置一个事务管理器 -->  
<bean id="transactionManager"  
    class="org.springframework.orm.hibernate4.HibernateTransactionManager">  
    <property name="sessionFactory" ref="sessionFactory" />  
</bean>  
       SSM中配置如下：

 

[html]  view plain  copy


<!-- 配置数据源 -->  
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">   
    <property name="driverClassName" value="${jdbc_driverClassName}"></property>  
</bean>  

<!-- 配置事务管理器 -->   
<bean name="transactionManager"  
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager">  
    <property name="dataSource" ref="dataSource" />  
</bean>  




         总结：Mybatils与hibernate在事务管理配置上有差别 —— Mybatils通常使用Spring默认的数据源事务管理器只要求相同数据源，不做其他配置；Hibernate使用专门的Spring事务管理器需要引用具备相同数据源的SessionFactory。


​            

 

3，Spring的事务管理方式有哪几种？如何配置并使用？（事务管理器创建完成，以它为基础配置事务标识——用来创建并管理事务）

​         

           包含两种： 编程式事务管理、声明式事务管理

 



              （一）其中编程式管理带来代码冗余，违背Spring简洁特性，基本上很少使用，例如：


​          

```java
int a=consumpDao.insert(s);//插入消费明细  
int b=customerDao.insert(customer);//此处实际应该update(customer),不然会出现重复主键的异常  
int d=0;  
if(a*b*d==1){  
    json.put("result",0);  
    json.put("msg", "购买成功");  
    json.put("data", "");  
}else{  
    json.put("result",-1);  
    json.put("msg", "购买失败");  
    json.put("data", "");  
    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();  
}  
```


                其中使用程序TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); 在没有异常抛出的情况下实现
    
    事务的手动回滚，如有疑问请访问链接：Spring事务为什么没有回滚？Spring事务怎样才会回滚？事务回滚的条件

 



       注意：尽管可以采用编程式方法回滚事务，但“回滚”只是事务的生命周期之一，所以要么编程实现事务的全部必要周期，要么仍要
    
           配置事务切点，即，将事务管理的其他周期交由Spring的标识！

 



          （二）其中声明式管理符合Spring的特性，被广泛使用 —— 注解易于配置，配置易于编程 ，它的实现具有两种常用方式：


​                

                ①一种是基于tx和aop切面拦截的xml配置文件：

 



[html]  view plain  copy


<tx:advice id="transactionAdvice" transaction-manager="transactionManager">   
<!-- 切点拦截的位置下，所有形式类似的方法名，‘事务’都会交由相应事务管理工具管理-->  
    <tx:attributes >  
        <tx:method name="insert*" propagation="REQUIRED"  />  
        <tx:method name="get*" propagation="REQUIRED" read-only="true" />  
    </tx:attributes>  
</tx:advice>  
<aop:config expose-proxy="true">  
    <aop:pointcut id="transactionPointcut" expression="execution(* com.local.*.*.*(..))" />  
    <aop:advisor pointcut-ref="transactionPointcut"  advice-ref="transactionAdvice" />  
</aop:config>  
                需要注意一下expression中*通配符的含义：

 

 

[html]  view plain  copy


<!-- 对所有层的事务方法进行切点拦截 *的含义：①所有返回类型 ②所有包③所有类 ④所有方法(..)标识方法内的所有参数  -->  
                当然，大多数时候我们都是在service层，实现事务管理的,即配置如下：

 

[html]  view plain  copy


<aop:config expose-proxy="true">  
    <aop:pointcut id="transactionPointcut" expression="execution(* com.local.service.*.*(..))" />  
    <aop:advisor pointcut-ref="transactionPointcut" advice-ref="transactionAdvice" />  
</aop:config>  
                只要在expression描述的范围下，方法名符合配置格式，事务的 ①开启  ②提交  ③回滚   ④关闭  ⑤清空就会依据具体配置交由Spring管理：

 

 

[java]  view plain  copy


@RequestMapping("consump")  
public void insertConsumption(Customer c,Consumption s,Mygift m) throws Exception{        
    JSONObject json =new JSONObject();  


               ②另一种就是基于@Transactional注解：

 



[html]  view plain  copy


<!-- 注解方式配置事物 -->  
    <tx:annotation-driven transaction-manager="transactionManager" />   
              @Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。

 

 

 

[java]  view plain  copy

@Transactional  
@RequestMapping("consump")  
public void insertConsumption(Customer c,Consumption s,Mygift m) throws Exception{        
    JSONObject json =new JSONObject();  
————————————————
版权声明：本文为CSDN博主「公众号：流花鬼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_32331073/article/details/76503433